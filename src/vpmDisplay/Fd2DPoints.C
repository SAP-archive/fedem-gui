// SPDX-FileCopyrightText: 2023 SAP SE
//
// SPDX-License-Identifier: Apache-2.0
//
// This file is part of FEDEM - https://openfedem.org
////////////////////////////////////////////////////////////////////////////////

///////////////////
//
//        This node was made by
//  Morten Eriksen from Norsk Simulator Senter
//           4.Dec.1996
//
/////////////////

#include <QtOpenGL/qgl.h>
#include <Inventor/SoDB.h>
#include <Inventor/actions/SoGLRenderAction.h>
#include <Inventor/elements/SoElement.h>
#include <Inventor/elements/SoViewVolumeElement.h>
#include <Inventor/elements/SoViewportRegionElement.h>
#include <Inventor/elements/SoLightModelElement.h>
#include <Inventor/elements/SoCacheElement.h>

#include "vpmDisplay/Fd2DPoints.H"


// This file is generated by using the 'ppmtoc' tool on raw PPM files.
// It includes the marker bitmap structure and the dimensions information.
#include "vpmDisplay/FdMarkerPicture.H"

// 2D point list structure nodes.
struct pointnode {
  long id;
  SbVec3f position;
  struct pointnode *next, *prev;
};

SO_NODE_SOURCE(Fd2DPoints);


void Fd2DPoints::init()
{
  SO_NODE_INIT_CLASS(Fd2DPoints, SoNode, "Node");

  // Flip the bitmap buffer to make it compliant with the OpenGL
  // 2D coordinate system.
  Fd2DPoints::flipBuffer(pixeldata, picturewidth, pictureheight);
}


Fd2DPoints::Fd2DPoints()
{
  SO_NODE_CONSTRUCTOR(Fd2DPoints);

  SO_NODE_ADD_FIELD(isOn, (1));
  SO_NODE_ADD_FIELD(useFastMarkers, (0));
  SO_NODE_ADD_FIELD(scale, (1.0));

  this->listhead = this->listtail = NULL;
  lastid = 1;

  // Initialize color values to maximum possible error.
  backgr[0] = 0x00; backgr[1] = 0x00; backgr[2] = 0x00;
  foregr[0] = 0xff; foregr[1] = 0xff; foregr[2] = 0xff;
  int bint = 0x00, fint = 0xff * 3;

  // Scan pixelbuffer to find lowest and highest intensity components.
  for(long i = 0; i < picturewidth*pictureheight; i++) {
    if(pixeldata[i*4+3]) {
      int intensity = pixeldata[i*4+0] + pixeldata[i*4+1] + pixeldata[i*4+2];
      if(intensity > bint) {
	bint = intensity;
	backgr[0] = pixeldata[i*4+0];
	backgr[1] = pixeldata[i*4+1];
	backgr[2] = pixeldata[i*4+2];
      }
      if(intensity < fint) {
	fint = intensity;
	foregr[0] = pixeldata[i*4+0];
	foregr[1] = pixeldata[i*4+1];
	foregr[2] = pixeldata[i*4+2];
      }
    }
  }

  // Initialize the float version of the background color values.
  // backgrf is used to set the color for the FastMarkers.
  backgrf[0] = ((float)backgr[0])/255.0;
  backgrf[1] = ((float)backgr[1])/255.0;
  backgrf[2] = ((float)backgr[2])/255.0;
}


Fd2DPoints::~Fd2DPoints()
{
  // Deallocate memory used in point list.
  this->removeAllPoints();
}


void Fd2DPoints::write(SoWriteAction*)
{
  // This is a dummy function made to avoid any output when this node
  // is writing itself to a file.
}


void Fd2DPoints::swapcols(unsigned char *from, unsigned char *to)
{
  // Scan through the pixelbuffer and swap the indicated component.
  for(long i = 0; i < picturewidth*pictureheight; i++) {
    if(pixeldata[i*4+3]) {
      if((pixeldata[i*4+0] == from[0]) &&
	 (pixeldata[i*4+1] == from[1]) &&
	 (pixeldata[i*4+2] == from[2])) {
	pixeldata[i*4+0] = to[0];
	pixeldata[i*4+1] = to[1];
	pixeldata[i*4+2] = to[2];
      }
    }
  }
}


void Fd2DPoints::changeForgrColor(SbColor newcol)
{
  // Change the color values for the foreground color.
  unsigned char bytecol[3];
  float f[3];

  newcol.getValue(f[0], f[1], f[2]);
  bytecol[0] = ((unsigned char)(f[0]*255.0));
  bytecol[1] = ((unsigned char)(f[1]*255.0));
  bytecol[2] = ((unsigned char)(f[2]*255.0));
  swapcols(foregr, bytecol);
  foregr[0] = bytecol[0];
  foregr[1] = bytecol[1];
  foregr[2] = bytecol[2];
  this->touch();
}


void Fd2DPoints::changeBckgrColor(SbColor newcol)
{
  // Change the color values for the background color.
  unsigned char bytecol[3];
  float f[3];

  newcol.getValue(f[0], f[1], f[2]);
  bytecol[0] = ((unsigned char)(f[0]*255.0));
  bytecol[1] = ((unsigned char)(f[1]*255.0));
  bytecol[2] = ((unsigned char)(f[2]*255.0));
  swapcols(backgr, bytecol);
  backgr[0] = bytecol[0];
  backgr[1] = bytecol[1];
  backgr[2] = bytecol[2];
  backgrf[0] = ((float)backgr[0])/255.0;
  backgrf[1] = ((float)backgr[1])/255.0;
  backgrf[2] = ((float)backgr[2])/255.0;
  this->touch();
}


long Fd2DPoints::addPoint(SbVec3f position)
{
  struct pointnode *newnode = new struct pointnode;
  if(!newnode) return 0;

  // Initialize a new point node.
  newnode->id = lastid++;
  newnode->position.setValue(position.getValue());
  newnode->next = NULL;
  newnode->prev = NULL;

  if(this->listhead) {
    this->listtail->next = newnode;
    newnode->prev = this->listtail;
    this->listtail = newnode;
  }
  else {
    this->listhead = this->listtail = newnode;
  }
#ifdef FD_DEBUG
  printf("Fd2DPoints:: Adding point %d to 2DPointlist at: %f, %f, %f\n",
	 newnode->id,
	 newnode->position[0], newnode->position[1], newnode->position[2]);
#endif
  this->touch();
  return newnode->id;
}


void Fd2DPoints::movePoint(long id, SbVec3f position)
{
  // Scan through list and find the point node with the given ID.
  struct pointnode *runner = this->listhead;
  while(runner && (runner->id != id)) runner = runner->next;

  // Move the point node.
  if(runner) {
    runner->position.setValue(position.getValue());
#ifdef FD_DEBUG
    printf("Fd2DPoints:: Moved point with id: %ld\n", id);
#endif
    this->touch();
  }
  // An error has occurred outside the class; somebody tried to move
  // a point with an invalid ID.
#ifdef FD_DEBUG
  else
    printf("Fd2DPoints:: Warning! Tried moving a point with invalid "
	   "id number %ld\n", id);
#endif
}


void Fd2DPoints::removePoint(long id)
{
  // Scan through list and find the point node with the given ID.
  struct pointnode *runner = this->listhead;
  while(runner && (runner->id != id)) runner = runner->next;

  // Unlink the point node from the list and deallocate memory used.
  if(runner) {
    if((runner == this->listhead) && (runner == this->listtail)) {
      this->listhead = this->listtail = NULL;
      delete runner;
    }
    else if(runner == this->listhead) {
      this->listhead->next->prev = NULL;
      this->listhead = this->listhead->next;
      delete runner;
    }
    else if(runner == this->listtail) {
      this->listtail->prev->next = NULL;
      this->listtail = this->listtail->prev;
      delete runner;
    }
    else {
      runner->prev->next = runner->next;
      runner->next->prev = runner->prev;
      delete runner;
    }
#ifdef FD_DEBUG
    printf("Fd2DPoints:: Removing point with id: %ld\n", id);
#endif
    this->touch();
  }
  // An error has occurred outside the class; somebody tried to remove
  // a point with an invalid ID.
#ifdef FD_DEBUG
  else
    printf("Fd2DPoints:: Warning! Couldn't find pointnode with"
	   " id number %ld\n", id);
#endif
}


void Fd2DPoints::removeAllPoints(void)
{
  // Deallocate all memory in point node list.
  struct pointnode *runner = this->listhead;
  while(runner) {
    this->listhead = runner->next;
    delete runner;
    runner = this->listhead;
  }
  this->touch();
#ifdef FD_DEBUG
  printf("Fd2DPoints:: Removing all points\n");
#endif
}


void Fd2DPoints::flipBuffer(unsigned char *buffer, int width, int height)
{

  // Flip all pixels around the y-axis to make the pixel buffer OpenGL
  // compliant.

  long i, j, w = width, h = height, topoffset, botoffset;
  unsigned char tmp;

  for(i = 0; i < h/2; i++) {
    topoffset = i*w*4;
    botoffset = (h-i-1)*w*4;

    for(j = 0; j < w*4; j += 4) {
      tmp = buffer[topoffset+j+0];
      buffer[topoffset+j+0] = buffer[botoffset+j+0];
      buffer[botoffset+j+0] = tmp;

      tmp = buffer[topoffset+j+1];
      buffer[topoffset+j+1] = buffer[botoffset+j+1];
      buffer[botoffset+j+1] = tmp;

      tmp = buffer[topoffset+j+2];
      buffer[topoffset+j+2] = buffer[botoffset+j+2];
      buffer[botoffset+j+2] = tmp;

      tmp = buffer[topoffset+j+3];
      buffer[topoffset+j+3] = buffer[botoffset+j+3];
      buffer[botoffset+j+3] = tmp;
    }
  }
}


void Fd2DPoints::GLRender(SoGLRenderAction *action)
{
  SoCacheElement::invalidate(action->getState());

  if(!this->isOn.getValue()) return;
  if(!this->listhead) return;

  GLboolean lightingenabled;
  GLboolean depthenabled, depthmask, blendenabled;
  GLint depthfunc, blendsrc, blenddest, matrixmode;
  GLfloat depthrange[2], xzoom, yzoom;

  // Save the Inventor state information.
  SoState *state = action->getState();
  state->push();
  glPushAttrib(GL_CURRENT_BIT);
  lightingenabled = glIsEnabled(GL_LIGHTING);
  glDisable(GL_LIGHTING);

  // Store GL state information for the variables that we might modify.
  depthenabled = glIsEnabled(GL_DEPTH_TEST);
  blendenabled = glIsEnabled(GL_BLEND);
  glGetIntegerv(GL_DEPTH_FUNC, &depthfunc);
  glGetBooleanv(GL_DEPTH_WRITEMASK, &depthmask);
  glGetIntegerv(GL_BLEND_SRC, &blendsrc);
  glGetIntegerv(GL_BLEND_DST, &blenddest);
  glGetIntegerv(GL_MATRIX_MODE, &matrixmode);
  glGetFloatv(GL_DEPTH_RANGE, depthrange);
  glGetFloatv(GL_ZOOM_X, &xzoom); glGetFloatv(GL_ZOOM_Y, &yzoom);

  // Push identiy matrices on top of the matrix stacks.
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(0, 1, 0, 1, -1, 1);

  // Set up state for drawing 2D "sprite" graphics which will always
  // lay on top of the Inventor-triggered rendering of 3D graphics.
  glDepthFunc(GL_ALWAYS);
  glDepthMask(GL_TRUE);
  glDepthRange(0, 0);
  glEnable(GL_DEPTH_TEST);
  // Make the alpha values valid.
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_BLEND);

  // Set the scale factor.
  glPixelZoom(this->scale.getValue(), this->scale.getValue());

  this->drawMarkers(state);

  // Reset original state for OpenGL and Inventor.
  glPixelZoom(xzoom, yzoom);

  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();

  glBlendFunc(blendsrc, blenddest);
  if(!blendenabled) glDisable(GL_BLEND);
  if(!depthenabled) glDisable(GL_DEPTH_TEST);
  if (lightingenabled) glEnable(GL_LIGHTING);
  glDepthRange(depthrange[0], depthrange[1]);
  glDepthFunc(depthfunc);
  glDepthMask(depthmask);
  glMatrixMode(matrixmode);

  glPopAttrib();

  state->pop();
}


SbBool Fd2DPoints::affectsState() const
{
  return FALSE;
}


void Fd2DPoints::drawMarkers(SoState *state)
{
  const SbViewVolume &vv = SoViewVolumeElement::get(state);
  const SbViewportRegion &vr = SoViewportRegionElement::get(state);
  SbVec3f planecoords;
  SbVec2s ws = vr.getWindowSize();
  float clampedwidth = 0.0f, clampedheight = 0.0f;

  // Precalculate these multiplication factors to get better performance
  // in the loop.
  float multfactor_X = 0.5/((float)ws[0])*this->scale.getValue();
  float multfactor_Y = 0.5/((float)ws[1])*this->scale.getValue();

  // If we're going to draw FastMarkers (i.e. rectangles), execute
  // this code to set the rectangle dimensions and colorvalue.
  if(this->useFastMarkers.getValue()) {
    glColor4f(backgrf[0], backgrf[1], backgrf[2], 1.0);
    clampedwidth =
      ((float)picturewidth)/((float)ws[0])*this->scale.getValue();
    clampedheight =
      ((float)pictureheight)/((float)ws[1])*this->scale.getValue();
  }

  // Traverse the point node list and draw all markers which are inside
  // the current viewport.
  struct pointnode *runner = this->listhead;
  while(runner) {
    vv.projectToScreen(runner->position, planecoords);
    // If we're using fast markers, draw rectangles instead of pixelbuffers.
    if(this->useFastMarkers.getValue()) {
      float x1 = planecoords[0] - picturewidth * multfactor_X;
      float y1 = planecoords[1] - pictureheight * multfactor_Y;
      float x2 = x1+clampedwidth;
      float y2 = y1+clampedheight;
      if((x2 >= 0) && (y2 >= 0))
	glRectf(x1 > 0 ? x1 : 0, y1 > 0 ? y1 : 0, x2, y2);
    }
    else {
      float x = planecoords[0] - picturewidth * multfactor_X;
      float y = planecoords[1] - pictureheight * multfactor_Y;
      float newwidth = picturewidth - (-x * ws[0]);
      float newheight = pictureheight - (-y * ws[1]);

      // Don't draw pixelbuffer if we're completely outside the viewport.
      if((newwidth <= 0) || (newheight <= 0)) {
      }
      // If we're only partly inside the viewport, some modulo values
      // need to be set.
      else if((x < 0) || (y < 0)) {
	glRasterPos2f(x > 0 ? x : 0, y > 0 ? y : 0);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, picturewidth);
	if(x<0) glPixelStorei(GL_UNPACK_SKIP_PIXELS,
			      ((int)(-x*((float)ws[0]))));
	if(y<0) glPixelStoref(GL_UNPACK_SKIP_ROWS,
			      ((int)(-y*((float)ws[1]))));
	glDrawPixels(x < 0 ? newwidth : picturewidth,
		     y < 0 ? newheight : pictureheight,
		     GL_RGBA, GL_UNSIGNED_BYTE, pixeldata);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
      }
      // We're completely inside the viewport - smash in the complete
      // pixelbuffer.
      else {
	glRasterPos2f(x, y);
	glDrawPixels(picturewidth,
		     pictureheight,
		     GL_RGBA, GL_UNSIGNED_BYTE,
		     pixeldata);
      }
    }

    runner = runner->next;
  }
}
